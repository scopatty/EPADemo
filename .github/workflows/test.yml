# azure-pipelines.yml - Conceptual Azure DevOps Pipeline for Council Tax Rebate Platform

# This YAML defines a CI/CD pipeline that would be configured in Azure DevOps.
# It assumes:
# 1. Your code (Python app, Terraform files) is in an Azure Repo or GitHub Repo.
# 2. You have created an Azure DevOps Project.
# 3. You have an Azure Resource Manager Service Connection configured in Azure DevOps
#    that uses the Service Principal created earlier via Terraform variables,
#    with Contributor role on your resource group.
# 4. Azure Pipelines agents have Python and ODBC drivers pre-installed, or you use tasks
#    to install them. Microsoft-hosted agents usually have Python.

name: Testing for YAML

On:
  workflow_dispatch:

pool:
  vmImage: 'ubuntu-latest' # Use a Microsoft-hosted agent (Linux for Python)

variables:
  # Azure subscription details for deployment
  azureSubscription: 'Your Azure Subscription Service Connection Name' # Name of your Azure DevOps Service Connection
  resourceGroupName: 'rg-rebate-devops-project' # Matches your Terraform variable
  webAppName: 'webapp-rebate-app' # Matches your Terraform variable
  webAppSlotName: 'staging' # Name of the staging deployment slot
  pythonVersion: '3.9' # Consistent Python version

# --- Stages ---
stages:
- stage: BuildAndTest
  displayName: 'Build and Test Application'
  jobs:
  - job: Build
    displayName: 'Build and Scan Python App'
    steps:
    - task: UsePythonVersion@0
      displayName: 'Use Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        addTo
        path: 'true'

    - displayName: 'Install dependencies'
      # Assuming a requirements.txt file for Python dependencies
      script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt pyodbc # Include pyodbc, ensure ODBC driver on agent
        pip install pylint bandit safety # Tools for static analysis and dependency checking

    - displayName: 'Run Unit Tests'
      # Adjust this based on your Python testing framework (e.g., pytest)
      script: |
        python -m pytest tests/ # Assuming you have a 'tests' directory with unit tests
      continueOnError: false # Fail the build if tests fail

    - displayName: 'Perform Static Analysis (SAST - Pylint, Bandit)'
      # Analyze your Python code for potential bugs and security vulnerabilities
      script: |
        pylint app.py # Basic linting
        bandit -r . # Security linter for Python code
      continueOnError: true # Don't fail the build, but report warnings

    - displayName: 'Perform Dependency Vulnerability Scan (Safety)'
      # Check installed Python packages for known vulnerabilities
      script: |
        safety check -r requirements.txt
      continueOnError: true # Don't fail the build, but report warnings

    - displayName: 'Scan for Committed Secrets (Example)'
      # Simple check for common secret patterns (consider dedicated tools for real use)
      script: |
        grep -r -E "password|secret|key|token" . | grep -v "app.secret_key" || true # Exclude known safe occurrences
      continueOnError: true

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Application Artifacts'
      inputs:
        pathToPublish: '$(Build.SourcesDirectory)' # Publish the entire source directory
        artifactName: 'drop' # Name of the artifact

- stage: DeployInfrastructure
  displayName: 'Deploy Azure Infrastructure (Terraform)'
  dependsOn: [] # Can run independently or after BuildAndTest
  condition: succeeded() # Only run if previous stage (if any) succeeded
  jobs:
  - job: TerraformApply
    displayName: 'Apply Terraform Changes'
    steps:
    - task: AzurePowerShell@5 # Or AzureCLI@2 for Bash
      displayName: 'Authenticate Terraform with Azure CLI (Service Principal)'
      inputs:
        azureSubscription: '$(azureSubscription)'
        ScriptType: 'InlineScript'
        Inline: |
          # The Service Principal used by the Azure DevOps Service Connection will provide auth
          # Terraform uses the Azure CLI credentials by default
          Write-Host "Azure CLI authentication managed by Azure DevOps Service Connection."

    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: 'latest' # Or a specific version like '1.7.0'

    - displayName: 'Terraform Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        backendServiceArm: '$(azureSubscription)'
        backendAzureRmResourceGroupName: '$(resourceGroupName)'
        backendAzureRmStorageAccountName: 'yourtfstatestorageacc' # Replace with your state storage account name
        backendAzureRmContainerName: 'tfstate'
        backendAzureRmKey: 'rebate-project.tfstate'
      workingDirectory: '$(Build.SourcesDirectory)/terraform-infra' # Assuming Terraform files are in this subfolder

    - displayName: 'Terraform Validate'
      inputs:
        provider: 'azurerm'
        command: 'validate'
      workingDirectory: '$(Build.SourcesDirectory)/terraform-infra'

    - displayName: 'Terraform Plan'
      inputs:
        provider: 'azurerm'
        command: 'plan'
        environmentServiceNameAzureRM: '$(azureSubscription)'
      workingDirectory: '$(Build.SourcesDirectory)/terraform-infra'

    - displayName: 'Terraform Apply (Requires Manual Approval in Production)'
      inputs:
        provider: 'azurerm'
        command: 'apply'
        environmentServiceNameAzureRM: '$(azureSubscription)'
        # autoApprove: true # REMOVE for production to require manual approval!
      workingDirectory: '$(Build.SourcesDirectory)/terraform-infra'
      # For production, you'd add an approval gate here.
      # Ex: environment: 'production' and configure approvals on the environment.


- stage: DeployApplication
  displayName: 'Deploy Application to App Service'
  dependsOn: BuildAndTest # Depends on successful build and tests
  condition: succeeded()
  jobs:
  - deployment: DeployWebApp
    displayName: 'Deploy Web App'
    environment: 'Production' # Link to an environment in Azure DevOps for approval gates
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@1
            displayName: 'Download Application Artifacts'
            inputs:
              artifactName: 'drop'
              # PathtoDownload: '$(System.DefaultWorkingDirectory)/_rebaterepo/drop' # Example if using a specific folder structure

          # --- Deploy to Staging Slot ---
          - task: AzureWebApp@1
            displayName: 'Deploy App to Staging Slot'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appName: '$(webAppName)'
              slotName: '$(webAppSlotName)' # Deploy to the staging slot
              package: '$(System.DefaultWorkingDirectory)/drop' # Path to your published artifact
              # If your Python app requires specific startup commands, use webAppConfig
              # webAppConfig: |
              #  - Handler: 'python'
              #  - PythonCmd: 'python -m flask run --host=0.0.0.0 --port=80' # Example for Flask

          - displayName: 'Run Integration/End-to-End Tests on Staging'
            # Assuming you have a separate test suite (e.g., Selenium/Playwright tests)
            # that targets the staging URL.
            script: |
              echo "Running automated E2E tests against staging environment at https://$(webAppName)-$(webAppSlotName).azurewebsites.net..."
              # Placeholder for actual test execution command
              # npm test -- --target-url https://$(webAppName)-$(webAppSlotName).azurewebsites.net
            continueOnError: false # Critical: Fail deployment if E2E tests fail

          # --- Manual Approval Gate ---
          # Add a manual intervention task or configure environment approvals in Azure DevOps
          # - task: ManualIntervention@8
          #   displayName: 'Manual Approval for Production Deployment'
          #   inputs:
          #     instructions: 'Review staging environment before approving production deployment.'
          #     timeoutInMinutes: 1440 # 24 hours to approve

          # --- Swap Slots for Zero-Downtime Deployment ---
          - task: AzureWebApp@1
            displayName: 'Swap Staging to Production Slot'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appName: '$(webAppName)'
              slotName: '$(webAppSlotName)' # Source slot
              targetSlot: 'production' # Target slot (implicitly the main site)
              resourceGroupName: '$(resourceGroupName)'
              preserveVnet: true # Crucial if you have VNet integration

          - displayName: 'Post-Deployment Smoke Tests on Production'
            script: |
              echo "Running smoke tests on production site https://$(webAppName).azurewebsites.net..."
              # Add curl/httpie/pytest-playwright commands to hit production endpoints
              # Example: curl -sL -w "%{http_code}" "https://$(webAppName).azurewebsites.net" -o /dev/null
